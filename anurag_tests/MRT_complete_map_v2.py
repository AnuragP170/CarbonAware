# uses the list of tuples generated by node_distance_calculator
# in progress



import networkx as nx
import matplotlib.pyplot as plt
import node_distance_calculator as nodeDist  # own module

class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, node):
        self.nodes[node] = {}

    def add_edge(self, node1, node2, weight):
        self.nodes[node1][node2] = weight
        self.nodes[node2][node1] = weight

    def dijkstra(self, start_node, end_node):
        distances = {node: float('inf') for node in self.nodes}
        distances[start_node] = 0
        visited = set()

        while len(visited) < len(self.nodes):
            current_node = None
            min_distance = float('inf')

            for node in self.nodes:
                if node not in visited and distances[node] < min_distance:
                    current_node = node
                    min_distance = distances[node]

            if current_node is None:  # Check if there are no more reachable nodes
                break

            visited.add(current_node)

            if current_node == end_node:  # Exit the loop if the end node is reached
                break

            if current_node not in self.nodes:  # Skip current node if it's not in the graph
                continue

            for neighbor, weight in self.nodes[current_node].items():
                distance = distances[current_node] + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance

        return distances[end_node]


yellow_stations = ['HarbourFront', 'Telok Blangah', 'Labrador Park',
                   'Pasir Panjang', 'Haw Par Villa', 'Kent Ridge', 'one-north',
                   'Buona Vista', 'Holland Village', 'Farrer Road', 'Botanic Gardens', 'Caldecott', 'Marymount',
                   'Bishan', 'Lorong Chuan', 'Serangoon', 'Bartley', 'Tai Seng', 'MacPherson', 'Paya Lebar', 'Dakota',
                   'Mountbatten', 'Stadium', 'Nicoll Highway', 'Promenade']

yellow_stations = nodeDist.mrt_list_generator(yellow_stations)
print(yellow_stations)

# Creating an empty graph
G = nx.Graph()

# Adding nodes and edges to the graph
for node1, node2, weight in yellow_stations:
    G.add_edge(node1, node2, weight=weight)

# Creating an instance of the Graph class
graph = Graph()

# Adding nodes and edges to the Graph class instance
for node1, node2, weight in yellow_stations:
    graph.add_node(node1)
    graph.add_node(node2)
    graph.add_edge(node1, node2, weight)

# Source and destination MRT stations
source_station = 'HarbourFront'
destination_station = 'Serangoon'

# Drawing the graph with highlighted optimal path
plt.figure(figsize=(20, 18))  # Set the size of the figure

# Applying Dijkstra's algorithm to find the optimal path
distances = graph.dijkstra(source_station, destination_station)

# Getting the optimal path
shortest_path = nx.shortest_path(G, source_station, destination_station)

# Drawing the graph with highlighted optimal path
pos = nx.spring_layout(G, seed=42, scale=5, k=0.9)

# Draw the optimal path in blue
path_edges = list(zip(shortest_path, shortest_path[1:]))
nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='magenta', width=4)
# Print the weights of the edges
edge_labels = {(node1, node2): weight for (node1, node2, weight) in yellow_stations}
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')

# Calculate the total distance traveled
total_distance = 0.0
for i in range(len(shortest_path) - 1):
    source = shortest_path[i]
    destination = shortest_path[i + 1]
    weight = graph.nodes[source][destination]
    total_distance += weight

# Print the total distance
print("Total Distance Traveled: {:.2f} km".format(total_distance))
# Printing the optimal path
print("Optimal Path:", shortest_path)

nx.draw_networkx(G, pos, with_labels=True, node_size=200, edge_color='gray')
plt.title('Subway Lines - Optimal Path from {} to {}'.format(source_station, destination_station))
plt.show()
